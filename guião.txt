O objetivo deste trabalho foi implementar o tão conhecido jogo "Conect-Four" em Python e analisar as diferenças na performance de vários algoritmos de pesquisa, algoritmos adversariais e não-adversariais. Para além do A star e do Monte Carlo, implementamos também o Mini-Max.

Os primeiros passos foram implementar as classes Board e Game, tendo em conta as regras do jogo. Para ser criado um tabuleiro, basta indicar o tamanho do mesmo (linhas e colunas). A classe tem métodos para verificar se dois tabuleiros são iguais, verificar se existe uma peça numa dada posição e qual é, colocar uma peça numa certa posição e verificar se um movimento é terminal, ou seja, se o jogo acabou. A classe Game recebe duas funções que determinam quais serão os algoritmos a participar no jogo e executa um certo número de jogos, retornando as estatísticas sobre os mesmos (tempo, percentagem de vitórias, etc)

Para implementar o A star, é primeiro necessário criar a classe Node. Cada nó guarda o estado do tabuleiro anterior e o movimento a ser executado. Um nó é melhor que outro quando tem um custo f menor e sabemos que f é g mais h, sendo g a "distância" e h a "heurística".
A função execute_a_star_move expande todos os nós, ou seja, investiga todos os próximos movimentos possíveis e escolhe o "melhor", tendo em conta a distância e a pontuiação da heurística. O algoritmo não tem em conta as jogadas do adversário e a árvore é expandida até chegar a um move terminal (até ganhar). 
A primeira heurística que criamos tem em conta o estado do tabuleiro anterior e apenas altera a pontuação acrescentando os pontos das posições em torno da nova peça jogada, ou seja, verificamos apenas os grupos de quatro a que aquela posição pertence e alteramos a pontuação tendo isso em conta.
A segunda heurística calcula a pontuação do zero, dado um tabuleiro, tendo em conta as regras descritas no pdf do trabalho.

Para implementar o Monte Carlo, é também necessário criar uma classe Node. Neste caso, cada nó guarda, para além do tabuleiro anterior e o movimento a ser executado, as vitórias e as visitas.
---
---
---
---

Mini-Max:
O algoritmo do Mini-Max visita todos os movimentos possíveis no tabuleiro e, para cada move, avalia o estado final. a função mini_max() avalia recursivamente um estado do jogo, ao explorar a árvore até uma certa profundidade. Se o estado atual for terminal ou a profundidade máxima tiver sido atingida, é dada uma certa pontuação. Senão, explora todos os moves possíveis, alternando entre maximizing e minimizing. Durante a pesquisa, atualiza os valores alpha e beta para eliminar ramos que não afetarão o resultado final.


Análise dos resultados:
---
---
---
---
---

